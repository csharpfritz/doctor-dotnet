using CodeMedic.Abstractions;
using CodeMedic.Abstractions.Plugins;
using CodeMedic.Engines;
using CodeMedic.Models;
using CodeMedic.Models.Report;
using CodeMedic.Output;
using CodeMedic.Plugins.HealthAnalysis;
using CodeMedic.Utilities;

namespace CodeMedic.Plugins.VulnerabilityAnalysis;

/// <summary>
/// Plugin that provides focused vulnerability scanning for NuGet packages.
/// </summary>
public class VulnerabilityAnalysisPlugin : IAnalysisEnginePlugin
{
    private VulnerabilityScanner? _scanner;

    /// <inheritdoc/>
    public PluginMetadata Metadata => new()
    {
        Id = "codemedic.vulnerabilities",
        Name = "Vulnerability Scanner",
        Version = VersionUtility.GetVersion(),
        Description = "Scans .NET projects for known vulnerabilities in NuGet package dependencies",
        Author = "CodeMedic Team",
        Tags = ["vulnerabilities", "security", "packages", "cve"]
    };

    /// <inheritdoc/>
    public string AnalysisDescription => "NuGet package vulnerability scan";

    /// <inheritdoc/>
    public Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        // No initialization required
        return Task.CompletedTask;
    }

    /// <inheritdoc/>
    public async Task<object> AnalyzeAsync(string repositoryPath, CancellationToken cancellationToken = default)
    {
        _scanner = new VulnerabilityScanner(repositoryPath);

        // Scan all projects for packages
        var packages = new List<Package>();
        var projectsByPackage = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);

        try
        {
            var projectFiles = Directory.EnumerateFiles(
                repositoryPath,
                "*.csproj",
                SearchOption.AllDirectories);

            foreach (var projectFile in projectFiles)
            {
                try
                {
                    var doc = System.Xml.Linq.XDocument.Load(projectFile);
                    var ns = doc.Root?.Name.NamespaceName ?? "";
                    var root = doc.Root;

                    if (root != null)
                    {
                        var inspector = new NuGetInspector(repositoryPath);
                        var projectDir = Path.GetDirectoryName(projectFile) ?? repositoryPath;
                        var projectName = Path.GetFileNameWithoutExtension(projectFile);
                        var pkgs = inspector.ReadPackageReferences(root, System.Xml.Linq.XNamespace.Get(ns), projectDir);

                        foreach (var pkg in pkgs)
                        {
                            if (!packages.Any(p => p.Name == pkg.Name && p.Version == pkg.Version))
                            {
                                packages.Add(pkg);
                            }

                            if (!projectsByPackage.ContainsKey($"{pkg.Name}@{pkg.Version}"))
                            {
                                projectsByPackage[$"{pkg.Name}@{pkg.Version}"] = [];
                            }
                            projectsByPackage[$"{pkg.Name}@{pkg.Version}"].Add(projectName);
                        }
                    }
                }
                catch
                {
                    // Skip projects that can't be parsed
                }
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error scanning projects: {ex.Message}");
        }

        // Scan packages for vulnerabilities
        var vulnBySeverity = new Dictionary<string, List<(Package pkg, PackageVulnerability vuln, List<string> projects)>>();

        foreach (var pkg in packages.OrderBy(p => p.Name))
        {
            var vulnerabilities = await _scanner.ScanPackageAsync(pkg.Name, pkg.Version, cancellationToken);

            foreach (var vuln in vulnerabilities)
            {
                if (!vulnBySeverity.ContainsKey(vuln.Severity))
                {
                    vulnBySeverity[vuln.Severity] = [];
                }

                var projectKey = $"{pkg.Name}@{pkg.Version}";
                var projectList = projectsByPackage.TryGetValue(projectKey, out var projects) ? projects : [];
                vulnBySeverity[vuln.Severity].Add((pkg, vuln, projectList));
            }
        }

        // Build report
        var report = new ReportDocument
        {
            Title = "NuGet Package Vulnerability Report"
        };

        report.Metadata["ScanTime"] = DateTime.UtcNow.ToString("u");
        report.Metadata["RootPath"] = repositoryPath;
        report.Metadata["TotalPackagesScanned"] = packages.Count.ToString();
        report.Metadata["TotalVulnerabilities"] = vulnBySeverity.Values.Sum(v => v.Count).ToString();

        // Summary section
        var summarySection = new ReportSection { Title = "Summary", Level = 1 };
        var totalVulns = vulnBySeverity.Values.Sum(v => v.Count);

        summarySection.AddElement(new ReportParagraph(
            $"Scanned {packages.Count} unique package(s), found {totalVulns} vulnerability(ies)",
            totalVulns > 0 ? TextStyle.Warning : TextStyle.Success
        ));

        var summaryKvList = new ReportKeyValueList();
        summaryKvList.Add("Total Packages Scanned", packages.Count.ToString());
        summaryKvList.Add("Total Vulnerabilities Found", totalVulns.ToString(),
            totalVulns > 0 ? TextStyle.Warning : TextStyle.Success);

        if (vulnBySeverity.Count > 0)
        {
            summaryKvList.Add("Critical", vulnBySeverity.TryGetValue("Critical", out var crit) ? crit.Count.ToString() : "0",
                vulnBySeverity.TryGetValue("Critical", out var crit2) && crit2.Count > 0 ? TextStyle.Error : TextStyle.Normal);
            summaryKvList.Add("High", vulnBySeverity.TryGetValue("High", out var high) ? high.Count.ToString() : "0",
                vulnBySeverity.TryGetValue("High", out var high2) && high2.Count > 0 ? TextStyle.Warning : TextStyle.Normal);
            summaryKvList.Add("Moderate", vulnBySeverity.TryGetValue("Moderate", out var mod) ? mod.Count.ToString() : "0");
            summaryKvList.Add("Low", vulnBySeverity.TryGetValue("Low", out var low) ? low.Count.ToString() : "0");
        }

        summarySection.AddElement(summaryKvList);
        report.AddSection(summarySection);

        // Vulnerabilities by severity
        if (vulnBySeverity.Count > 0)
        {
            var severityOrder = new Dictionary<string, int>
            {
                { "Critical", 4 },
                { "High", 3 },
                { "Moderate", 2 },
                { "Low", 1 }
            };

            foreach (var severity in vulnBySeverity.Keys.OrderByDescending(k => severityOrder.TryGetValue(k, out var ord) ? ord : 0))
            {
                var vulnSection = new ReportSection
                {
                    Title = $"Vulnerabilities - {severity}",
                    Level = 1
                };

                var vulnTable = new ReportTable();
                vulnTable.Headers.AddRange(new[]
                {
                    "Package",
                    "Version",
                    "CVE ID",
                    "Description",
                    "Fixed In",
                    "Projects Affected"
                });

                foreach (var (pkg, vuln, projects) in vulnBySeverity[severity].OrderBy(v => v.vuln.PackageName))
                {
                    vulnTable.AddRow(
                        vuln.PackageName,
                        vuln.AffectedVersion,
                        vuln.VulnerabilityId,
                        vuln.Description,
                        vuln.FixedInVersion ?? "Unknown",
                        string.Join(", ", projects)
                    );
                }

                vulnSection.AddElement(vulnTable);
                report.AddSection(vulnSection);
            }
        }
        else
        {
            var noVulnSection = new ReportSection { Title = "Status", Level = 1 };
            noVulnSection.AddElement(new ReportParagraph(
                "âœ“ No known vulnerabilities found in scanned packages!",
                TextStyle.Success
            ));
            report.AddSection(noVulnSection);
        }

        return report;
    }

    /// <inheritdoc/>
    public CommandRegistration[]? RegisterCommands()
    {
        return
        [
            new CommandRegistration
            {
                Name = "vulnerabilities",
                Description = "Scan for known vulnerabilities in NuGet packages",
                Handler = ExecuteVulnerabilityCommandAsync,
                Arguments =
                [
                    new CommandArgument(
                        Description: "Path to the repository to scan",
                        ShortName: "p",
                        LongName: "path",
                        HasValue: true,
                        ValueName: "path",
                        DefaultValue: "current directory")
                ],
                Examples =
                [
                    "codemedic vulnerabilities",
                    "codemedic vulnerabilities -p /path/to/repo",
                    "codemedic vulnerabilities --path /path/to/repo --format markdown",
                    "codemedic vulnerabilities > vulnerabilities-report.txt"
                ]
            }
        ];
    }

    private async Task<int> ExecuteVulnerabilityCommandAsync(string[] args, IRenderer renderer)
    {
        try
        {
            // Parse arguments (target path only)
            string? targetPath = args.IdentifyTargetPathFromArgs();

            // Render banner and header
            renderer.RenderBanner();
            renderer.RenderSectionHeader("NuGet Package Vulnerability Report");

            // Run analysis
            var repositoryPath = targetPath ?? Directory.GetCurrentDirectory();
            object? reportDocument = null;

            await renderer.RenderWaitAsync($"Running {AnalysisDescription}...", async () =>
            {
                reportDocument = await AnalyzeAsync(repositoryPath);
            });

            // Render report
            if (reportDocument != null)
            {
                renderer.RenderReport(reportDocument);
            }

            return 0;
        }
        catch (Exception ex)
        {
            CodeMedic.Commands.RootCommandHandler.Console.RenderError($"Failed to scan for vulnerabilities: {ex.Message}");
            return 1;
        }
    }
}
