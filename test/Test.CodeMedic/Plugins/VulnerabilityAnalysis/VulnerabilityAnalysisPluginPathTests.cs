using CodeMedic.Abstractions.Plugins;
using CodeMedic.Plugins.VulnerabilityAnalysis;
using Moq;
using CodeMedic.Abstractions;

namespace Test.CodeMedic.Plugins.VulnerabilityAnalysis;

/// <summary>
/// Unit tests for VulnerabilityAnalysisPlugin path argument functionality.
/// </summary>
public class VulnerabilityAnalysisPluginPathTests
{
    private readonly VulnerabilityAnalysisPlugin _plugin;

    public VulnerabilityAnalysisPluginPathTests()
    {
        _plugin = new VulnerabilityAnalysisPlugin();
    }

    [Fact]
    public void RegisterCommands_WhenCalled_ThenReturnsCommandWithPathArgument()
    {
        // When
        var commands = _plugin.RegisterCommands();

        // Then
        Assert.NotNull(commands);
        Assert.Single(commands);
        
        var command = commands[0];
        Assert.Equal("vulnerabilities", command.Name);
        Assert.Equal("Scan for known vulnerabilities in NuGet packages", command.Description);
        
        Assert.NotNull(command.Arguments);
        Assert.Single(command.Arguments);
        
        var pathArg = command.Arguments[0];
        Assert.Equal("Path to the repository to scan", pathArg.Description);
        Assert.Equal("p", pathArg.ShortName);
        Assert.Equal("path", pathArg.LongName);
        Assert.False(pathArg.IsRequired);
        Assert.True(pathArg.HasValue);
        Assert.Equal("current directory", pathArg.DefaultValue);
        Assert.Equal("path", pathArg.ValueName);
    }

    [Fact]
    public void RegisterCommands_WhenCalled_ThenReturnsCommandWithCorrectExamples()
    {
        // When
        var commands = _plugin.RegisterCommands();

        // Then
        var command = commands![0];
        Assert.NotNull(command.Examples);
        Assert.Contains("codemedic vulnerabilities", command.Examples);
        Assert.Contains("codemedic vulnerabilities -p /path/to/repo", command.Examples);
        Assert.Contains("codemedic vulnerabilities --path /path/to/repo --format markdown", command.Examples);
        Assert.Contains("codemedic vulnerabilities > vulnerabilities-report.txt", command.Examples);
    }

    [Fact]
    public async Task ExecuteVulnerabilityCommandAsync_GivenEmptyArgs_WhenCalled_ThenUsesCurrentDirectory()
    {
        // Given
        var mockRenderer = new Mock<IRenderer>();
        var command = _plugin.RegisterCommands()![0];
        var args = Array.Empty<string>();

        // Setup the renderer to avoid actual rendering
        mockRenderer.Setup(r => r.RenderBanner()).Verifiable();
        mockRenderer.Setup(r => r.RenderSectionHeader(It.IsAny<string>())).Verifiable();
        mockRenderer.Setup(r => r.RenderWaitAsync(It.IsAny<string>(), It.IsAny<Func<Task>>()))
            .Returns<string, Func<Task>>((_, action) => action())
            .Verifiable();
        mockRenderer.Setup(r => r.RenderReport(It.IsAny<object>())).Verifiable();

        // When & Then - Should not throw and should call renderer methods
        var result = await command.Handler(args, mockRenderer.Object);
        
        // Verify renderer was called appropriately
        mockRenderer.Verify(r => r.RenderBanner(), Times.Once);
        mockRenderer.Verify(r => r.RenderSectionHeader("NuGet Package Vulnerability Report"), Times.Once);
        mockRenderer.Verify(r => r.RenderWaitAsync(
            It.Is<string>(s => s.Contains("NuGet package vulnerability scan")), 
            It.IsAny<Func<Task>>()), Times.Once);
    }

    [Fact]
    public async Task ExecuteVulnerabilityCommandAsync_GivenShortPathArg_WhenCalled_ThenUsesSpecifiedPath()
    {
        // Given
        var mockRenderer = new Mock<IRenderer>();
        var command = _plugin.RegisterCommands()![0];
        var testPath = Path.GetTempPath();
        var args = new[] { "-p", testPath };

        // Setup the renderer
        mockRenderer.Setup(r => r.RenderBanner()).Verifiable();
        mockRenderer.Setup(r => r.RenderSectionHeader(It.IsAny<string>())).Verifiable();
        mockRenderer.Setup(r => r.RenderWaitAsync(It.IsAny<string>(), It.IsAny<Func<Task>>()))
            .Returns<string, Func<Task>>((_, action) => action())
            .Verifiable();
        mockRenderer.Setup(r => r.RenderReport(It.IsAny<object>())).Verifiable();

        // When
        var result = await command.Handler(args, mockRenderer.Object);

        // Then - Should complete without throwing
        mockRenderer.Verify(r => r.RenderBanner(), Times.Once);
        mockRenderer.Verify(r => r.RenderSectionHeader("NuGet Package Vulnerability Report"), Times.Once);
    }

    [Fact]
    public async Task ExecuteVulnerabilityCommandAsync_GivenLongPathArg_WhenCalled_ThenUsesSpecifiedPath()
    {
        // Given
        var mockRenderer = new Mock<IRenderer>();
        var command = _plugin.RegisterCommands()![0];
        var testPath = Path.GetTempPath();
        var args = new[] { "--path", testPath };

        // Setup the renderer
        mockRenderer.Setup(r => r.RenderBanner()).Verifiable();
        mockRenderer.Setup(r => r.RenderSectionHeader(It.IsAny<string>())).Verifiable();
        mockRenderer.Setup(r => r.RenderWaitAsync(It.IsAny<string>(), It.IsAny<Func<Task>>()))
            .Returns<string, Func<Task>>((_, action) => action())
            .Verifiable();
        mockRenderer.Setup(r => r.RenderReport(It.IsAny<object>())).Verifiable();

        // When
        var result = await command.Handler(args, mockRenderer.Object);

        // Then - Should complete without throwing
        mockRenderer.Verify(r => r.RenderBanner(), Times.Once);
        mockRenderer.Verify(r => r.RenderSectionHeader("NuGet Package Vulnerability Report"), Times.Once);
    }

    [Fact]
    public void Metadata_WhenAccessed_ThenReturnsCorrectInformation()
    {
        // When
        var metadata = _plugin.Metadata;

        // Then
        Assert.Equal("codemedic.vulnerabilities", metadata.Id);
        Assert.Equal("Vulnerability Scanner", metadata.Name);
        Assert.Equal("Scans .NET projects for known vulnerabilities in NuGet package dependencies", metadata.Description);
        Assert.Equal("CodeMedic Team", metadata.Author);
        Assert.NotNull(metadata.Tags);
        Assert.Contains("vulnerabilities", metadata.Tags);
        Assert.Contains("security", metadata.Tags);
        Assert.Contains("packages", metadata.Tags);
        Assert.Contains("cve", metadata.Tags);
    }

    [Fact]
    public void AnalysisDescription_WhenAccessed_ThenReturnsCorrectDescription()
    {
        // When
        var description = _plugin.AnalysisDescription;

        // Then
        Assert.Equal("NuGet package vulnerability scan", description);
    }

    [Fact] 
    public async Task InitializeAsync_WhenCalled_ThenCompletesSuccessfully()
    {
        // When & Then - Should complete without throwing
        await _plugin.InitializeAsync();
    }

    [Fact]
    public async Task ExecuteVulnerabilityCommandAsync_GivenRelativePathArg_WhenCalled_ThenProcessesSuccessfully()
    {
        // Given
        var mockRenderer = new Mock<IRenderer>();
        var command = _plugin.RegisterCommands()![0];
        var args = new[] { "-p", "." };

        // Setup minimal renderer mock
        mockRenderer.Setup(r => r.RenderBanner());
        mockRenderer.Setup(r => r.RenderSectionHeader(It.IsAny<string>()));
        mockRenderer.Setup(r => r.RenderWaitAsync(It.IsAny<string>(), It.IsAny<Func<Task>>()))
            .Returns<string, Func<Task>>((_, action) => action());
        mockRenderer.Setup(r => r.RenderReport(It.IsAny<object>()));

        // When & Then - Should not throw
        var result = await command.Handler(args, mockRenderer.Object);
        
        // Verify basic renderer calls were made
        mockRenderer.Verify(r => r.RenderBanner(), Times.Once);
        mockRenderer.Verify(r => r.RenderSectionHeader("NuGet Package Vulnerability Report"), Times.Once);
    }

    [Fact]
    public async Task ExecuteVulnerabilityCommandAsync_GivenParentDirectoryPath_WhenCalled_ThenProcessesSuccessfully()
    {
        // Given
        var mockRenderer = new Mock<IRenderer>();
        var command = _plugin.RegisterCommands()![0];
        var args = new[] { "--path", ".." };

        // Setup minimal renderer mock
        mockRenderer.Setup(r => r.RenderBanner());
        mockRenderer.Setup(r => r.RenderSectionHeader(It.IsAny<string>()));
        mockRenderer.Setup(r => r.RenderWaitAsync(It.IsAny<string>(), It.IsAny<Func<Task>>()))
            .Returns<string, Func<Task>>((_, action) => action());
        mockRenderer.Setup(r => r.RenderReport(It.IsAny<object>()));

        // When & Then - Should not throw
        var result = await command.Handler(args, mockRenderer.Object);
        
        // Verify basic renderer calls were made
        mockRenderer.Verify(r => r.RenderBanner(), Times.Once);
        mockRenderer.Verify(r => r.RenderSectionHeader("NuGet Package Vulnerability Report"), Times.Once);
    }
}